#ifndef PAGETABLES_HPP_
#define PAGETABLES_HPP_

/**
 * Here we define a page table structure just like how x86 tables work, see:
 * http://en.wikipedia.org/wiki/File:X86_Paging_4K.svg
 * This lets us lookup pages in a decently fast way without using trees or hashes etc
**/

#include "MemoryStorage.hpp"


#define PAGEDIR_TABLE_COUNT 0x400
#define PAGETABLE_PAGE_COUNT 0x400

#define PAGEDIR_TABLE_MASK (PAGEDIR_TABLE_COUNT-1)
#define PAGETABLE_PAGE_MASK (PAGETABLE_PAGE_COUNT-1)

#define PAGETABLE_PAGE_SHIFT 12
#define PAGEDIR_TABLE_SHIFT 22

#define PAGEDIR_ADDR2TABLEID(addr) ((addr >> PAGEDIR_TABLE_SHIFT) & PAGEDIR_TABLE_MASK)
#define PAGETABLE_ADDR2PAGEID(addr) ((addr >> PAGETABLE_PAGE_SHIFT) & PAGETABLE_PAGE_MASK)


class pagetable_t{
public:
	void* entry[PAGETABLE_PAGE_COUNT];

	pagetable_t(){
		// valgrind doesn't support instructions generated by the
		// compiler for this loop at high optimisation levels, grr
#ifndef VALGRIND
		for (int i=0; i < PAGETABLE_PAGE_COUNT; ++i)
			entry[i] = NULL;
#else
		for (int i=PAGETABLE_PAGE_COUNT-1; i >= 0; --i)
			entry[i] = NULL;
#endif
	};

	~pagetable_t(){
		for (int i=0; i < PAGETABLE_PAGE_COUNT; ++i)
			FREE(entry[i]);
	};
};


class pagedir_t{
public:
	pagetable_t* entry[PAGEDIR_TABLE_COUNT];

	pagedir_t(){
		// valgrind doesn't support instructions generated by the
		// compiler for this loop at high optimisation levels, grr
#ifndef VALGRIND
		for (int i=0; i < PAGEDIR_TABLE_COUNT; ++i)
			entry[i] = NULL;
#else
		for (int i=PAGEDIR_TABLE_COUNT-1; i >= 0; --i)
			entry[i] = NULL;
#endif
	};

	~pagedir_t(){
		for (int i=0; i < PAGEDIR_TABLE_COUNT; ++i)
			DELETE(entry[i])
	};
};


class pagetables : public MemoryStorage{
public:
	void* const getsetpage(const uInt page_addr, void* const newpage);
	void const setpage(const uInt page_addr, void* const newpage);
	void* const getpage(const uInt page_addr) const;

private:
	pagedir_t pagedir PAGE_ALIGNED;
};


#endif /* PAGETABLES_HPP_ */
